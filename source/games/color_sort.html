<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <!-- Ensure proper scaling on mobile devices -->
  <meta name="viewport" content="width=device-width, initial-scale=1">
  <title>Color Sorting Game - Mobile Friendly</title>
  <style>
    body {
      font-family: sans-serif;
      margin: 20px;
    }
    .container {
      margin-bottom: 20px;
    }
    /* Slider (grid size) styling */
    .slider-container {
      margin-bottom: 20px;
    }
    /* Palette styling */
    #color-palette {
      border: 2px solid #aaa;
      padding: 10px;
      min-height: 80px;
    }
    .color {
      width: 60px;
      height: 60px;
      margin: 5px;
      display: inline-block;
      border: 1px solid #333;
      cursor: grab;
      /* Prevent default touch actions */
      touch-action: none;
    }
    /* Grid styling: grid-template-columns will be updated dynamically */
    #color-grid {
      display: grid;
      grid-gap: 20px;
      padding: 10px;
      padding-right: 20px;
      border: 2px dashed #aaa;
      width: max-content;
    }
    .slot {
      width: 70px;
      height: 70px;
      border: 2px dashed #ccc;
      position: relative;
      display: flex;
      align-items: center;
      justify-content: center;
      /* A gentle transition for color changes (does not move the slot) */
      transition: background-color 0.2s, border-color 0.2s;
    }
    /* Highlight the slot without moving it:
       Change the border to light red and the background to light cream. */
    .slot.highlight {
      border-color: #ff9999;       /* Light red */
      background-color: #fff5e6;    /* Light cream */
    }
    /* Button container */
    #button-container {
      margin-top: 10px;
    }
  </style>
</head>
<body>
  <!-- Grid Size Controls (each slider on its own line) -->
  <div class="container slider-container">
    <div>
      <label for="rowsSlider">Rows: <span id="rowsLabel">1</span></label><br>
      <input type="range" id="rowsSlider" min="1" max="8" value="1">
    </div>
    <div style="margin-top: 10px;">
      <label for="colsSlider">Columns: <span id="colsLabel">4</span></label><br>
      <input type="range" id="colsSlider" min="2" max="8" value="4">
    </div>
  </div>
  
  <!-- Buttons moved immediately after sliders -->
  <div class="container" id="button-container">
    <button id="rearrangeButton">Rearrange for Best Score</button>
    <button id="resetButton">Reset Game</button>
  </div>
  
  <!-- Palette: Where the random color blocks are initially placed -->
  <div class="container">
    <h2>Palette (Drag or touch‑drag these colors)</h2>
    <div id="color-palette">
      <!-- Color blocks added dynamically -->
    </div>
  </div>
  
  <!-- Grid: The colors can be arranged here -->
  <div class="container">
    <h2>Grid (Arrange the colors)</h2>
    <div id="color-grid">
      <!-- Slots will be created dynamically -->
    </div>
  </div>
  
  <!-- Score Display -->
  <div class="container">
    <h2>Score: <span id="score">0.00</span></h2>
  </div>
  
  <script>
    // Global variables for grid dimensions and total colors.
    let numRows = 1;  // default from slider (1–8)
    let numCols = 4;  // default from slider (min 2–8)
    let numColors = numRows * numCols;
    
    // --- Helper Functions ---
    // Return a random integer from 0 to 255.
    function randomInt() {
      return Math.floor(Math.random() * 256);
    }
    
    // Generate a random RGBA color (alpha fixed at 255).
    function randomColor() {
      const r = randomInt();
      const g = randomInt();
      const b = randomInt();
      const a = 255;
      return [r, g, b, a];
    }
    
    // Compute cosine similarity between two 4D vectors.
    function cosineSimilarity(v1, v2) {
      const dot = v1[0]*v2[0] + v1[1]*v2[1] + v1[2]*v2[2] + v1[3]*v2[3];
      const norm1 = Math.sqrt(v1[0]**2 + v1[1]**2 + v1[2]**2 + v1[3]**2);
      const norm2 = Math.sqrt(v2[0]**2 + v2[1]**2 + v2[2]**2 + v2[3]**2);
      if (norm1 === 0 || norm2 === 0) return 0;
      return dot / (norm1 * norm2);
    }
    
    // Compute the total score by summing cosine similarities between adjacent colors.
    function computeScore() {
      const grid = document.getElementById('color-grid');
      const slots = Array.from(grid.children);
      let totalScore = 0;
      
      slots.forEach((slot, index) => {
        if (!slot.firstChild || !slot.firstChild.classList.contains('color')) return;
        const r = parseInt(slot.firstChild.getAttribute('data-r'));
        const g = parseInt(slot.firstChild.getAttribute('data-g'));
        const b = parseInt(slot.firstChild.getAttribute('data-b'));
        const a = parseInt(slot.firstChild.getAttribute('data-a'));
        const currentColor = [r, g, b, a];
        const row = Math.floor(index / numCols);
        const col = index % numCols;
        
        // Check right neighbor.
        if (col < numCols - 1) {
          const rightSlot = slots[index + 1];
          if (rightSlot && rightSlot.firstChild && rightSlot.firstChild.classList.contains('color')) {
            const r2 = parseInt(rightSlot.firstChild.getAttribute('data-r'));
            const g2 = parseInt(rightSlot.firstChild.getAttribute('data-g'));
            const b2 = parseInt(rightSlot.firstChild.getAttribute('data-b'));
            const a2 = parseInt(rightSlot.firstChild.getAttribute('data-a'));
            totalScore += cosineSimilarity(currentColor, [r2, g2, b2, a2]);
          }
        }
        // Check bottom neighbor.
        if (row < numRows - 1) {
          const bottomSlot = slots[index + numCols];
          if (bottomSlot && bottomSlot.firstChild && bottomSlot.firstChild.classList.contains('color')) {
            const r2 = parseInt(bottomSlot.firstChild.getAttribute('data-r'));
            const g2 = parseInt(bottomSlot.firstChild.getAttribute('data-g'));
            const b2 = parseInt(bottomSlot.firstChild.getAttribute('data-b'));
            const a2 = parseInt(bottomSlot.firstChild.getAttribute('data-a'));
            totalScore += cosineSimilarity(currentColor, [r2, g2, b2, a2]);
          }
        }
      });
      
      document.getElementById('score').textContent = totalScore.toFixed(2);
    }
    
    // --- Mobile Drag & Drop Support via Touch Events ---
    let currentDragged = null;
    let offsetX = 0;
    let offsetY = 0;
    
    function handleTouchStart(e) {
      e.preventDefault();
      currentDragged = e.currentTarget;
      const touch = e.touches[0];
      const rect = currentDragged.getBoundingClientRect();
      offsetX = touch.clientX - rect.left;
      offsetY = touch.clientY - rect.top;
      // Make the element follow the touch.
      currentDragged.style.position = "fixed";
      currentDragged.style.zIndex = "1000";
    }
    
    function handleTouchMove(e) {
      e.preventDefault();
      if (!currentDragged) return;
      const touch = e.touches[0];
      currentDragged.style.left = (touch.clientX - offsetX) + "px";
      currentDragged.style.top = (touch.clientY - offsetY) + "px";
      
      // Temporarily hide the dragged element so underlying targets can be detected.
      currentDragged.style.display = "none";
      let target = document.elementFromPoint(touch.clientX, touch.clientY);
      currentDragged.style.display = "";
      
      // Remove highlight from all slots.
      const slots = document.querySelectorAll('.slot');
      slots.forEach(slot => slot.classList.remove('highlight'));
      
      if (target) {
        // Walk up the DOM to check for a slot.
        let slotElement = target;
        while (slotElement && slotElement !== document.body) {
          if (slotElement.classList && slotElement.classList.contains('slot')) {
            slotElement.classList.add('highlight');
            break;
          }
          slotElement = slotElement.parentElement;
        }
      }
    }
    
    function handleTouchEnd(e) {
      if (!currentDragged) return;
      // Remove highlight from all slots.
      const slots = document.querySelectorAll('.slot');
      slots.forEach(slot => slot.classList.remove('highlight'));
      
      const touch = e.changedTouches[0];
      // Temporarily hide the dragged element to detect drop target.
      currentDragged.style.display = "none";
      let dropTarget = document.elementFromPoint(touch.clientX, touch.clientY);
      currentDragged.style.display = "";
      
      let validTarget = null;
      while (dropTarget && dropTarget !== document.body) {
        if (dropTarget.classList && (dropTarget.classList.contains('slot') || dropTarget.id === "color-palette")) {
          validTarget = dropTarget;
          break;
        }
        dropTarget = dropTarget.parentElement;
      }
      const palette = document.getElementById('color-palette');
      if (validTarget) {
        if (validTarget.id === "color-palette") {
          validTarget.appendChild(currentDragged);
        } else if (validTarget.classList.contains('slot')) {
          if (validTarget.firstChild) {
            palette.appendChild(validTarget.firstChild);
          }
          validTarget.appendChild(currentDragged);
        }
      } else {
        palette.appendChild(currentDragged);
      }
      // Reset styling.
      currentDragged.style.position = "";
      currentDragged.style.zIndex = "";
      currentDragged.style.left = "";
      currentDragged.style.top = "";
      currentDragged = null;
      computeScore();
    }
    
    // Attach touch event listeners to a color element.
    function addTouchHandlers(colorDiv) {
      colorDiv.addEventListener('touchstart', handleTouchStart, {passive: false});
      colorDiv.addEventListener('touchmove', handleTouchMove, {passive: false});
      colorDiv.addEventListener('touchend', handleTouchEnd);
    }
    
    // --- Create Draggable Color Elements ---
    function createColorElement(id, rgba) {
      const colorDiv = document.createElement('div');
      colorDiv.classList.add('color');
      colorDiv.id = id;
      colorDiv.setAttribute('data-r', rgba[0]);
      colorDiv.setAttribute('data-g', rgba[1]);
      colorDiv.setAttribute('data-b', rgba[2]);
      colorDiv.setAttribute('data-a', rgba[3]);
      colorDiv.style.backgroundColor = `rgba(${rgba[0]}, ${rgba[1]}, ${rgba[2]}, ${rgba[3] / 255})`;
      colorDiv.setAttribute('draggable', 'true');
      
      // Desktop drag support.
      colorDiv.addEventListener('dragstart', (e) => {
        e.dataTransfer.setData('text/plain', colorDiv.id);
      });
      
      // Mobile/touch support.
      addTouchHandlers(colorDiv);
      
      return colorDiv;
    }
    
    // --- Setup Functions ---
    function setupPalette() {
      const palette = document.getElementById('color-palette');
      palette.innerHTML = "";
      for (let i = 0; i < numColors; i++) {
        const rgba = randomColor();
        const colorDiv = createColorElement('color' + i, rgba);
        palette.appendChild(colorDiv);
      }
    }
    
    function setupGrid() {
      const grid = document.getElementById('color-grid');
      grid.innerHTML = "";
      grid.style.gridTemplateColumns = `repeat(${numCols}, 60px)`;
      for (let i = 0; i < numColors; i++) {
        const slot = document.createElement('div');
        slot.classList.add('slot');
        slot.addEventListener('dragover', (e) => { e.preventDefault(); });
        slot.addEventListener('drop', (e) => {
          e.preventDefault();
          const draggedId = e.dataTransfer.getData('text/plain');
          const draggedEl = document.getElementById(draggedId);
          const palette = document.getElementById('color-palette');
          if (slot.firstChild) {
            palette.appendChild(slot.firstChild);
          }
          slot.appendChild(draggedEl);
          computeScore();
        });
        // Double‑click (or double‑tap) to return a color to the palette.
        slot.addEventListener('dblclick', () => {
          if (slot.firstChild) {
            const palette = document.getElementById('color-palette');
            palette.appendChild(slot.firstChild);
            computeScore();
          }
        });
        grid.appendChild(slot);
      }
    }
    
    function setupPaletteDrop() {
      const palette = document.getElementById('color-palette');
      palette.addEventListener('dragover', (e) => { e.preventDefault(); });
      palette.addEventListener('drop', (e) => {
        e.preventDefault();
        const draggedId = e.dataTransfer.getData('text/plain');
        const draggedEl = document.getElementById(draggedId);
        palette.appendChild(draggedEl);
        computeScore();
      });
    }
    
    // --- Optimization: Rearranging for a Best Score ---
    function rearrangeBest() {
      const palette = document.getElementById('color-palette');
      const grid = document.getElementById('color-grid');
      const paletteColors = Array.from(palette.children).filter(el => el.classList.contains('color'));
      const gridColors = Array.from(grid.children)
                           .filter(slot => slot.firstChild && slot.firstChild.classList.contains('color'))
                           .map(slot => slot.firstChild);
      let allColors = paletteColors.concat(gridColors);
      if (allColors.length !== numColors) {
        alert("Not all colors are placed. Please ensure all colors are either in the palette or in the grid.");
        return;
      }
      
      let currentArrangement = allColors.slice();
      let currentScore = getArrangementScore(currentArrangement);
      let bestArrangement = currentArrangement.slice();
      let bestScore = currentScore;
      
      let T = 1.0;
      const coolingFactor = 0.9995;
      const iterations = 10000;
      
      for (let iter = 0; iter < iterations; iter++) {
        const i = Math.floor(Math.random() * currentArrangement.length);
        let j = Math.floor(Math.random() * currentArrangement.length);
        while (j === i) {
          j = Math.floor(Math.random() * currentArrangement.length);
        }
        [currentArrangement[i], currentArrangement[j]] = [currentArrangement[j], currentArrangement[i]];
        const newScore = getArrangementScore(currentArrangement);
        const delta = newScore - currentScore;
        if (delta >= 0 || Math.random() < Math.exp(delta / T)) {
          currentScore = newScore;
          if (newScore > bestScore) {
            bestScore = newScore;
            bestArrangement = currentArrangement.slice();
          }
        } else {
          [currentArrangement[i], currentArrangement[j]] = [currentArrangement[j], currentArrangement[i]];
        }
        T *= coolingFactor;
      }
      
      const slots = Array.from(grid.children);
      slots.forEach(slot => slot.innerHTML = "");
      for (let i = 0; i < bestArrangement.length; i++) {
        slots[i].appendChild(bestArrangement[i]);
      }
      palette.innerHTML = "";
      computeScore();
    }
    
    function getArrangementScore(arr) {
      let score = 0;
      for (let i = 0; i < arr.length; i++) {
        const r = parseInt(arr[i].getAttribute('data-r'));
        const g = parseInt(arr[i].getAttribute('data-g'));
        const b = parseInt(arr[i].getAttribute('data-b'));
        const a = parseInt(arr[i].getAttribute('data-a'));
        const currentColor = [r, g, b, a];
        const row = Math.floor(i / numCols);
        const col = i % numCols;
        if (col < numCols - 1) {
          const r2 = parseInt(arr[i+1].getAttribute('data-r'));
          const g2 = parseInt(arr[i+1].getAttribute('data-g'));
          const b2 = parseInt(arr[i+1].getAttribute('data-b'));
          const a2 = parseInt(arr[i+1].getAttribute('data-a'));
          score += cosineSimilarity(currentColor, [r2, g2, b2, a2]);
        }
        if (row < numRows - 1 && (i + numCols) < arr.length) {
          const r2 = parseInt(arr[i+numCols].getAttribute('data-r'));
          const g2 = parseInt(arr[i+numCols].getAttribute('data-g'));
          const b2 = parseInt(arr[i+numCols].getAttribute('data-b'));
          const a2 = parseInt(arr[i+numCols].getAttribute('data-a'));
          score += cosineSimilarity(currentColor, [r2, g2, b2, a2]);
        }
      }
      return score;
    }
    
    // --- Game Reset and Dimension Update ---
    function resetGame() {
      setupPalette();
      setupGrid();
      setupPaletteDrop();
      computeScore();
    }
    
    function updateDimensions() {
      const rowsSlider = document.getElementById('rowsSlider');
      const colsSlider = document.getElementById('colsSlider');
      const rowsLabel = document.getElementById('rowsLabel');
      const colsLabel = document.getElementById('colsLabel');
      
      numRows = parseInt(rowsSlider.value);
      numCols = parseInt(colsSlider.value);
      rowsLabel.textContent = numRows;
      colsLabel.textContent = numCols;
      numColors = numRows * numCols;
      
      resetGame();
    }
    
    // --- Initialization ---
    document.addEventListener('DOMContentLoaded', () => {
      const rowsSlider = document.getElementById('rowsSlider');
      const colsSlider = document.getElementById('colsSlider');
      rowsSlider.addEventListener('input', updateDimensions);
      colsSlider.addEventListener('input', updateDimensions);
      
      resetGame();
      
      document.getElementById('rearrangeButton').addEventListener('click', rearrangeBest);
      document.getElementById('resetButton').addEventListener('click', resetGame);
    });
  </script>
</body>
</html>